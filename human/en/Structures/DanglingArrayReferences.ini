name = "Dangling Array References";
description = "Always unset a referenced-variable used in a loop.

It is highly recommended to unset blind variables when they are set up as references after a loop. 
When omitting this step, the next loop that will also require this variable will deal with garbage values, and produce unexpected results.";
code = "<?php

$array = array(1,2,3,4);

foreach($array as &$a) {
    $a += 1;
}
// This only unset the reference, not the value
unset($a);


// Dangling array problem
foreach($array as &$a) {
    $a += 1;
}
//$array === array(3,4,5,6);

// This does nothing (apparently)
// $a is already a reference, even if it doesn't show here.
foreach($array as $a) {}
//$array === array(3,4,5,5);

?>";
clearphp = "no-dangling-reference";
severity = "S_MAJOR";
; from : S_NONE, S_MINOR, S_MAJOR, S_CRITICAL
timetofix = "T_INSTANT";
; from : T_INSTANT, T_QUICK, T_SLOW
exakatSince = "0.8.4";
precision = "P_VERY_HIGH";
; from : P_VERY_HIGH, P_HIGH, P_MEDIUM, P_LOW, P_UNKNOWN
modifications[] = "Avoid using the reference altogether : sometimes, the reference is not needed.";
modifications[] = "Add unset() right after the loop, to avoid reusing the reference.";
; Alternative to make this code go away. 
; One by possible solution

features[] = "loop";
; Name of a PHP feature. 
; This should match one of the available feature description in humane/en/Features

seeAlso[] = "`No Dangling Reference <https://github.com/dseguy/clearPHP/blob/master/rules/no-dangling-reference.md>`_";
seeAlso[] = "`PHP foreach pass-by-reference: Do it right, or better not at all <https://coderwall.com/p/qx3fpa/php-foreach-pass-by-reference-do-it-right-or-better-not-at-all>`_";
seeAlso[] = "`How does PHP 'foreach' actually work? <https://stackoverflow.com/questions/10057671/how-does-php-foreach-actually-work/14854568#14854568>`_";
seeAlso[] = "`References and foreach <https://schlueters.de/blog/archives/141-references-and-foreach.html>`_";
; List of links of interest

related[] = "Structures/AlteringForeachWithoutReference";
; Possible other rules that might be related to this one. 
; Use "Folder/Name" format, one each
phpVersion = "";
; Versions when this feature was deprecated. Beyond is removed, and before is fine.
; This might need a range : 7.3-7.4.

phpDeprecation = "";
; Versions when this feature was deprecated. Beyond is removed, and before is fine.
; This might need a range : 7.3-7.4.
phpErrors[] = "";
; A PHP error that may be emitted by the target faulty code

keywords[] = "";
; Human readable keywords for manual glossary

changedBehavior = "";
; Which version did that behavior changed
changedBehavior_details = "";


[example1]
project = "Typo3";
file = "typo3/sysext/impexp/Classes/ImportExport.php";
line = "322";
code = "
if (is_array($this->dat['header']['pagetree'])) {
    reset($this->dat['header']['pagetree']);
    $lines = [];
    $this->traversePageTree($this->dat['header']['pagetree'], $lines);

    $viewData['dat'] = $this->dat;
    $viewData['update'] = $this->update;
    $viewData['showDiff'] = $this->showDiff;
    if (!empty($lines)) {
        foreach ($lines as &$r) {
            $r['controls'] = $this->renderControls($r);
            $r['fileSize'] = GeneralUtility::formatSize($r['size']);
            $r['message'] = ($r['msg'] && !$this->doesImport ? '<span class=text-danger>' . htmlspecialchars($r['msg']) . '</span>' : '');
        }
        $viewData['pagetreeLines'] = $lines;
    } else {
        $viewData['pagetreeLines'] = [];
    }
}
// Print remaining records that were not contained inside the page tree:
if (is_array($this->remainHeader['records'])) {
    $lines = [];
    if (is_array($this->remainHeader['records']['pages'])) {
        $this->traversePageRecords($this->remainHeader['records']['pages'], $lines);
    }
    $this->traverseAllRecords($this->remainHeader['records'], $lines);
    if (!empty($lines)) {
        foreach ($lines as &$r) {
            $r['controls'] = $this->renderControls($r);
            $r['fileSize'] = GeneralUtility::formatSize($r['size']);
            $r['message'] = ($r['msg'] && !$this->doesImport ? '<span class=text-danger>' . htmlspecialchars($r['msg']) . '</span>' : '');
        }
        $viewData['remainingRecords'] = $lines;
    }
}
";
explain = "foreach() reads $lines into $r, and augment those lines. By the end, the $r variable is not unset. Yet, several lines later, in the same method but with different conditions, another loop reuse the variable $r. If is_array($this->dat['header']['pagetree'] and is_array($this->remainHeader['records']) are arrays at the same moment, then both loops are called, and they share the same reference. Values of the latter array will end up in the formar. ";

[example2]
project = "SugarCrm";
file = "SugarCE-Full-6.5.26/modules/Import/CsvAutoDetect.php";
line = "165";
code = "
foreach ($this->_parser->data as &$row) {
    foreach ($row as &$data) {
        $len = strlen($data);
        // check if it begins and ends with single quotes
        // if it does, then it double quotes may not be the enclosure
        if ($len>=2 && $data[0] == \" && $data[$len-1] == \") {
            $beginEndWithSingle = true;
            break;
        }
    }
    if ($beginEndWithSingle) {
        break;
    }
    $depth++;
    if ($depth > $this->_max_depth) {
        break;
    }
}
";
explain = "There are two nested foreach here : they both have referenced blind variables. The second one uses $data, but never changes it. Yet, it is reused the next round in the first loop, leading to pollution from the first rows of $this->_parser->data into the lasts. This may happen even if $data is not modified explicitly : in fact, it will be modified the next call to foreach($row as ...), for each element in $row. ";
